#!/usr/bin/python2.5

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt
from pylab import *

import abcsysbio
import numpy
import sys
import re

from abcsysbio import parse_info
from abcsysbio import model
from abcsysbio import abcsmc
from abcsysbio import input_output
from abcsysbio import checkInputArguments
from abcsysbio import kernels
from abcsysbio import euclidian

import sys
sys.path.insert(0, ".")

def printOptions():
    
    print "\nList of possible options:"

    print "\n Input options:"
    print "-i\t--infile\t declaration of the input file. This input file has to be provided to run the program!"
    print "-pm\t--pythonmodel\t do not import model from sbml intead use .py file"

    print "\n Algorithmic options:"
    print "-sd\t--setseed\t seed the random number generator in numpy with an integer eg -sd=2, --setseed=2"
    print "-rm\t--runmode\t integer specifying standard (0), fast (1), cuda (2) eg -rm=2, --runmode=2. default 0."
    print "-cb\t--cudablocks\t number of thread blocks to run eg -cb=4, --cudablocks=4"
    print "-ct\t--cudathreads\t number of threads per thread block to run eg -ct=512, --cudathreads=512"
    print "-cc\t--cudacode\t cuda application code eg -cc=app.txt, --cudacode=app.txt"
    print "-mt\t--mtdata\t path to Mersenne Twister data file eg -mt=MersenneTwister.dat"
    print "-tm\t--timing\t print timing information"

    print "\n Output options:"  
    print "-of\t--outfolder\t write results to folder eg -of=/full/path/to/folder (default is _results_ in current directory)"
    print "-f\t--fulloutput\t print epsilon, sampling steps and acceptence rates after each population"
    print "-s\t--save\t\t no backup after each population"

    print "\n Simulate options:"
    print "-y\t--synthetic\t print a synthetic data set at the timepoints given in the input file, using initial conditions and constant parameters"
    print "-S\t--simulate\t simulate the model over the range of timepoints, using initial conditions and constant parameters"
    print "-sf\t--simfile\t output the simulated or synthetic data to a file, eg -sf=out.txt, --simfile=out.txt"

    print "\n Plotting options:"
    print "-d\t--diagnostic\t no printing of diagnostic plots"
    print "-t\t--timeseries\t no plotting of simulation results after each population"
    print "-p\t--plotdata\t no plotting of given data points"
    print "\n-h\t--help\t\t print this list of options."

    print "\n"

    
def main():
    
    diagnostic=True
    pickling=True
    file_exist=False
    plot=True
    plotTimeSeries=True
    simulate=False
    synthetic=False
    full=False
    usesbml=True
    seed = None
    runmode = 0
    timing = False
    nblock = None
    nthread = None
    fname = "_results_"
    app_file = "app.txt"
    simfile = "sim.txt"
    custom_kernel = False
    custom_distance = False
    use_cuda = False

    for i in range(1,len(sys.argv)):

        if sys.argv[i].startswith('--'):
            option = sys.argv[i][2:]
          
            if option == 'help':
                printOptions()
                sys.exit()
            elif option == 'diagnostic': diagnostic=False
            elif option == 'save': pickling=False
            elif option == 'timeseries': plotTimeSeries=False
            elif option == 'plotdata': plot=False
            elif option == 'simulate': simulate=True
            elif option == 'fulloutput': full=True
            elif option == 'synthetic':
                simulate=True
                synthetic=True
	    elif option == 'pythonmodel' : usesbml = False 
            elif option[0:8] == 'setseed=' : seed = int( option[8:] )
            elif option[0:8] == 'runmode=' : runmode = int( option[8:] )
            elif option[0:10] == 'outfolder=' : fname = option[10:]
            elif option[0:9] == 'cudacode=' : app_file = option[9:]
            elif option[0:8] == 'simfile=' : simfile = option[8:]
	    elif option == 'timing' : timing = True 
	    elif option == 'custk' : custom_kernel = True
	    elif option == 'custd' : custom_distance = True
            elif option == 'cuda' : use_cuda = True
	    elif option == 'infile': 
                input_file=sys.argv[i+1]
                file_exist=True
	    elif not(sys.argv[i-1][2:] == 'infile'): 
                print "\nunknown option "+sys.argv[i]
                printOptions()
                sys.exit()
            
        
        elif sys.argv[i].startswith('-'):
            option = sys.argv[i][1:]
            if option == 'h':
                printOptions()
                sys.exit()
            elif option == 'd': diagnostic=False
            elif option == 's': pickling=False
            elif option == 't': plotTimeSeries=False
            elif option == 'p': plot=False
            elif option == 'S': simulate=True
            elif option == 'f': full=True
            elif option == 'cu': use_cuda = True
            elif option == 'y':
                simulate=True
                synthetic=True
	    elif option == 'pm' : usesbml = False
            elif option[0:3] == 'sd=' : seed = int( option[3:] )
            elif option[0:3] == 'rm=' : runmode = int( option[3:] )
            elif option[0:3] == 'of=' : fname = option[3:]
            elif option[0:3] == 'cc=' : app_file = option[3:]
            elif option[0:3] == 'sf=' : simfile = option[3:]
            elif option == 'tm' : timing = True
            elif option == 'i': 
                input_file=sys.argv[i+1]
                file_exist=True
            elif not(sys.argv[i-1][2:] == 'i'): 
                print "\nunknown option "+sys.argv[i]
                printOptions()
                sys.exit()
        elif not((sys.argv[i-1][2:] == 'infile') or (sys.argv[i-1][1:] == 'i')):
            print "\nunknown expression \""+sys.argv[i]+"\""
            printOptions()
            sys.exit()

    if file_exist == False:
        print "\nNo input_file is given!\nUse: \n\t-i 'inputfile' \nor: \n\t--infile 'inputfile' \n"
        sys.exit()

    # parse the input file
    info_new = parse_info.algorithm_info(input_file) 
    info_new.print_info()

    # Check that we have libSBML if it is requested
    if usesbml == True:
        try: import libsbml
        except ImportError:
            print "ABORT: libSBML required for SBML parsing. Please install libSBML"
            sys.exit()

    # Check that we can import scipy if we have ODE models
    o = re.compile('ODE')
    for m in range( info_new.nmodels ):
        if o.search(info_new.type[m]):
            try: from scipy.integrate.odepack import odeint
            except ImportError:
                print "ABORT: scipy required for ODE modelling. Please install scipy"
                sys.exit()
            break

    # Check that we have cuda-sim installed
    if use_cuda == True:
        try: import cudasim
        except ImportError:
            print "ABORT: cudasim required for running on CUDA GPUs. Please install cuda-sim"
            sys.exit()
    
    # set the random seeds
    if seed != None:
	print "#### Seeding random number generator : ", seed
        numpy.random.seed(seed)

        
    if simulate==False :            

        # Check the information is correct for inference
	modelCorrect = False
        if usesbml == True : 
            if( use_cuda == False):
                abcsysbio.importSBML(info_new.source,info_new.type,info_new.name)
            else:
                import cudasim.SBMLParser
                itype = info_new.type[:]
               
                for i in range(len(itype)):
                    if itype[i] == "Gillespie" : itype[i] = "MJP"
                    
                cudasim.SBMLParser.importSBMLCUDA(info_new.source, itype, ModelName=info_new.name, method=None, outpath="./")

            modelCorrect, message = checkInputArguments.checkInputABC( info_new , fname, custom_distance )
        else:
            info_new.source = None
            modelCorrect, message = checkInputArguments.checkInputABC( info_new , fname, custom_distance )
               
        if modelCorrect==False:
            print message
            sys.exit()

                
        ########################### MODEL CREATION
        #
        # create a list of model objects from the information we have
        models = []
        for i in range(info_new.modelnumber):
            if( use_cuda == False ):
                new_model = model.model( name=info_new.name[i], nspecies=info_new.nspecies[i], nparameters=info_new.nparameters[i], prior=info_new.prior[i], 
                                         source=info_new.name[i], integration=info_new.type[i], fit=info_new.fit[i],
                                         init = info_new.init[i], dt=info_new.dt, atol=info_new.atol, rtol=info_new.rtol)
            else:
                new_model = model.cuda_model( name=info_new.name[i], nspecies=len(info_new.initValues[i]), nparameters=len(info_new.prior[i]), prior=info_new.prior[i], 
                                              source=info_new.name[i], integration=info_new.type[i], fit=info_new.fit[i],
                                              init = info_new.initValues[i], dt=info_new.dt, beta=info_new.BETA, timepoints=info_new.times)
            
            models.append( new_model )
            
        ########################### DATA CREATION
        #
        # create a data object
        data_new = model.data( info_new.times, info_new.data )

        ########################### IO
        #
        io = input_output.input_output(fname,info_new.restart, diagnostic, plotTimeSeries )
        io.create_output_folders(info_new.name, info_new.particles, pickling)
	if plot == True:
	    io.plot_data(data_new)

        ########################### ABC SMC
        #
	debug = 0
	if full == True: debug = 1

        # set the required distance and kernel functions
        distancefn = euclidian.euclidianDistance
        kernelfn = kernels.getKernel
        kernelpdffn = kernels.getPdfParameterKernel
        perturbfn = kernels.perturbParticle

        if custom_distance == True or custom_kernel == True:
            import customABC
            if custom_distance == True:
                distancefn = customABC.distance
            if custom_kernel == True:
                kernelfn = customABC.getKernel
                kernelpdffn = customABC.getPdfParameterKernel
                perturbfn = customABC.perturbParticle

        nbatch = 10
        if use_cuda == True:
            nbatch = 25000/info_new.BETA

        # instantiate the abcsmc algorithm class
        algorithm = abcsmc.abcsmc(models, info_new.particles, info_new.modelprior, data=data_new, beta = info_new.beta, nbatch=nbatch,
                                  modelKernel=info_new.modelkernel, debug=debug, timing=timing, distancefn=distancefn, kernelfn=kernelfn, kernelpdffn=kernelpdffn, perturbfn=perturbfn )

        # fill data from disk if required
        if info_new.restart == True:
            algorithm.fill_values( io.read_pickled(info_new.fname) )
            
	# transpose epsilon so it is epsilon[npop][ndistance]
	tepsilon = info_new.epsilon.transpose()
	#for i in range(len(info_new.epsilon[0])):
        #    e = []
        #    for j in range(len(info_new.epsilon)):
        #        e.append( info_new.epsilon[j][i] )
        #    tepsilon.append(e)

        # run ABC SMC
        algorithm.run_fixed_schedule(tepsilon, io)
        
        exit()

    else :
        print "simulations not implemented!"
	
        # if -S or --simulate option applies, simulate data at timepoints in infile using initialValues in infile.
        # plots are made - do we want to do anythin else e.g. save the data to a text file?
        
        ## name, timepoints, InitValues, type, ConstantParameters, source, dt, rtol, atol = abcsysbio.parseInfo.getInfoForSimulation(input_file)

##         if usesbml == True : 
##             modelCorrect, message = abcsysbio.checkInputArguments.checkInputSimulation(name, 
##                                                                                        timepoints, 
##                                                                                        InitValues, 
##                                                                                        type, 
##                                                                                        ConstantParameters, 
##                                                                                        source, 
##                                                                                        dt)
##             if modelCorrect == False:
##                 print message
##                 sys.exit()   

##             abcsysbio.importSBML(source,type,name)

##         if synthetic!=True:
##             timepoints=numpy.arange(timepoints[0], timepoints[-1]+dt, dt)

##         f = open(simfile,'w')
##         for i in range(0, len(name)):
##             data=abcsysbio.abcSMC_model.simulateData(name,i,type,InitValues,timepoints,ConstantParameters[i],dt)

##             print >>f, name[i]
##             for nd in range(len(timepoints)):
##                 print >>f, timepoints[nd],
##                 for np in range(len(data[0])):
##                     print >>f, data[nd][np],
##                 print >>f, ""
##             print >>f, "\n"
            
##             if synthetic==True:
##                 #print >>simfile, name[i]
##                 #print data
##                 plt.plot(timepoints, data, 'o')
##                 plt.savefig("Synthetic_Data_"+name[i])
##                 clf()
##             else: 
##                 plt.plot(timepoints, data)
##                 plt.savefig("Simulated_Data_"+name[i])
##                 clf()


main()
